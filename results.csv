problem_id,prompt,ngram_len,g_score,status,output,generated_code,attempts
0,"An accordion is a string (yes, in the real world accordions are musical instruments, but let's forget about it for a while) which can be represented as a concatenation of: an opening bracket (ASCII code $091$), a colon (ASCII code $058$), some (possibly zero) vertical line characters (ASCII code $124$), another colon, and a closing bracket (ASCII code $093$). The length of the accordion is the number of characters in it.

For example, [::], [:||:] and [:|||:] are accordions having length $4$, $6$ and $7$. (:|:), {:||:}, [:], ]:||:[ are not accordions. 

You are given a string $s$. You want to transform it into an accordion by removing some (possibly zero) characters from it. Note that you may not insert new characters or reorder existing ones. Is it possible to obtain an accordion by removing characters from $s$, and if so, what is the maximum possible length of the result?


-----Input-----

The only line contains one string $s$ ($1 \le |s| \le 500000$). It consists of lowercase Latin letters and characters [, ], : and |.


-----Output-----

If it is not possible to obtain an accordion by removing some characters from $s$, print $-1$. Otherwise print maximum possible length of the resulting accordion.


-----Examples-----
Input
|[a:b:|]

Output
4

Input
|]:[|:]

Output
-1",None,0.4926123023033142,Passed,,"def solution(s):
    # write your code in Python 3.6
    a = s.find('[')
    b = s.find(':')
    c = s.find('|')
    d = s.rfind(']')
    e = s.rfind(':')
    
    if a < 0 or b < 0 or c < 0 or d < 0 or e < 0:
        return -1
    
    count = 0
    for i in s:
        if i == '[' or i == ':' or i == '|' or i == ']':
            count += 1
    if count == 0:
        return 0
    if count == 1:
        if a > 0 and b > 0 and c > 0 and d > 0 and e > 0:
            return 1
        else:
            return -1
    if count == 2:
        if a > 0 and b > 0 and c > 0 and d > 0 and e > 0:
            return 3
        else:
            return -1
    if count == 3:
        if a > 0 and b > 0 and c > 0 and d > 0 and e > 0:
            return 5
        else:
            return -1
    if count == 4:
        if a > 0 and b > 0 and c > 0 and d > 0 and e > 0:
            return 7
        else:
            return -1
    if count > 4:
        if a > 0 and b > 0 and c > 0 and d > 0 and e > 0:
            return 9
        else:
            return -1
    return 0",2
0,"An accordion is a string (yes, in the real world accordions are musical instruments, but let's forget about it for a while) which can be represented as a concatenation of: an opening bracket (ASCII code $091$), a colon (ASCII code $058$), some (possibly zero) vertical line characters (ASCII code $124$), another colon, and a closing bracket (ASCII code $093$). The length of the accordion is the number of characters in it.

For example, [::], [:||:] and [:|||:] are accordions having length $4$, $6$ and $7$. (:|:), {:||:}, [:], ]:||:[ are not accordions. 

You are given a string $s$. You want to transform it into an accordion by removing some (possibly zero) characters from it. Note that you may not insert new characters or reorder existing ones. Is it possible to obtain an accordion by removing characters from $s$, and if so, what is the maximum possible length of the result?


-----Input-----

The only line contains one string $s$ ($1 \le |s| \le 500000$). It consists of lowercase Latin letters and characters [, ], : and |.


-----Output-----

If it is not possible to obtain an accordion by removing some characters from $s$, print $-1$. Otherwise print maximum possible length of the resulting accordion.


-----Examples-----
Input
|[a:b:|]

Output
4

Input
|]:[|:]

Output
-1",2,0.5403348803520203,Passed,,"import fractions
from functools import reduce
from operator import add

def chars_to_accordion(s):
    return reduce(add, [1] + [s.rfind(c) - s.find(c) for c in ('[', ':', ']')])

def main():
    N = int(input())
    for _ in range(N):
        s = input().rstrip()
        print(chars_to_accordion(s) if chars_to_accordion(s) else -1)


if __name__ == '__main__':
    main()",2
0,"An accordion is a string (yes, in the real world accordions are musical instruments, but let's forget about it for a while) which can be represented as a concatenation of: an opening bracket (ASCII code $091$), a colon (ASCII code $058$), some (possibly zero) vertical line characters (ASCII code $124$), another colon, and a closing bracket (ASCII code $093$). The length of the accordion is the number of characters in it.

For example, [::], [:||:] and [:|||:] are accordions having length $4$, $6$ and $7$. (:|:), {:||:}, [:], ]:||:[ are not accordions. 

You are given a string $s$. You want to transform it into an accordion by removing some (possibly zero) characters from it. Note that you may not insert new characters or reorder existing ones. Is it possible to obtain an accordion by removing characters from $s$, and if so, what is the maximum possible length of the result?


-----Input-----

The only line contains one string $s$ ($1 \le |s| \le 500000$). It consists of lowercase Latin letters and characters [, ], : and |.


-----Output-----

If it is not possible to obtain an accordion by removing some characters from $s$, print $-1$. Otherwise print maximum possible length of the resulting accordion.


-----Examples-----
Input
|[a:b:|]

Output
4

Input
|]:[|:]

Output
-1",5,0.5745097994804382,Passed,"-1
","s = input(""Please enter the string "")
temp_str = ""[::""
acc_str = """"
flag = True
for i in range (len(s)):
    for j in range(len(s)):
        temp_str = temp_str + s[j]
        if temp_str == ""][:|:"":
            flag = False
            for k in range (len(temp_str)):
                acc_str = acc_str + temp_str[k]
            print(acc_str)
            break
        else:
            if i == len(s) -1:
                flag = False
    if flag == True:
        print(-1)
        break
    else:
        temp_str = ""[::""",2
0,"An accordion is a string (yes, in the real world accordions are musical instruments, but let's forget about it for a while) which can be represented as a concatenation of: an opening bracket (ASCII code $091$), a colon (ASCII code $058$), some (possibly zero) vertical line characters (ASCII code $124$), another colon, and a closing bracket (ASCII code $093$). The length of the accordion is the number of characters in it.

For example, [::], [:||:] and [:|||:] are accordions having length $4$, $6$ and $7$. (:|:), {:||:}, [:], ]:||:[ are not accordions. 

You are given a string $s$. You want to transform it into an accordion by removing some (possibly zero) characters from it. Note that you may not insert new characters or reorder existing ones. Is it possible to obtain an accordion by removing characters from $s$, and if so, what is the maximum possible length of the result?


-----Input-----

The only line contains one string $s$ ($1 \le |s| \le 500000$). It consists of lowercase Latin letters and characters [, ], : and |.


-----Output-----

If it is not possible to obtain an accordion by removing some characters from $s$, print $-1$. Otherwise print maximum possible length of the resulting accordion.


-----Examples-----
Input
|[a:b:|]

Output
4

Input
|]:[|:]

Output
-1",10,0.5288520455360413,Passed,"2
","from functools import *

s = input()

res = []
for i in range(len(s)):
    curr = [i, 1]
    for j in range(i+1, len(s)):
        if s[i] == '[' and s[j] == ']' or s[i] == ':' and s[j] == '|':
            curr[1] += 1
        elif s[i] == '[' and s[j] == '|' or s[i] == ':' and s[j] == '[':
            break
    res.append(curr[1])

print(max(res) if len(res) > 0 else -1)

# OR
# from functools import *
#
# s = input()
#
# res = []
# for i in range(len(s)):
#     curr = [i, 1]
#     for j in range(i+1, len(s)):
#         if (s[i] == '[' and s[j] == ']' or s[i] == ':' and s[j] == '|') and curr[1] > 0:
#             curr[1] -= 1
#         elif (s[i] == '[' and s[j] == '|' or s[i] == ':' and s[j] == '['):
#             break
#     res.append(curr[1])
#
# print(max(res) if len(res) > 0 else -1)",1
